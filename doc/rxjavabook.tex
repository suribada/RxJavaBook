\documentclass{book}
\usepackage[utf8]{inputenc}
 
\title{안드로이드에 적용하는 RxJava2}
\author{노재춘}
\date{\today}
 
\begin{document}
 
\maketitle
예외 처리를 선언적으로는 하는 부분을 살펴보자.
양에 따라 chapter, section을 구분할 필요가 있을 듯 하다.
\chapter*{머리말}
시중에 볼 수 있는 RxJava 책들이 많다. 국내에도 번역서가 2개가 나와있다. 
여러 책들에서 안드로이드를 지원하는 내용도 나오는데, 안드로이드 앱 개발에서 고려해야 할 사항이 충분히 나오지 않은 듯 하다. 게다가 샘플 가운데서는 안드로이드에서는 동작하지 않는 것도 있었다.

오라일리 Reactive Programming With RxJava(번역서 RxJava를 활용한 리액티브 프로그래밍)와 Learning RxJava(Packt)를 많이 참조했다.

이 책은 RxJava를 활용하는 내용 뿐 아니라 분석한 내용도 포함하고 있다.
코틀린 내용은 제외하였다.

원리를 알면 각 내용을 외울 필요가 없다. 

용어에 답이 있거나 질문 안에 답이 있는 경우가 많다.

알고나면 안 쓰면 불편하다.
\tableofcontents

웹 문서 인용은 주석에 주로 주석에 표시한다. 책 인용은 본문에 주로 표시하고 번역서가 있는 경우는 번역서를 표시하고 번역서가 없는 경우에 원서를 표시한다. 


https://ahea.wordpress.com/2017/02/13/reactive-streams/
https://www.reactivemanifesto.org/ko
http://junsikshim.github.io/2017/04/13/Why-Reactive.html
https://www.oreilly.com/learning/why-reactive
https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339

<장제목>1장 리액티브 익스텐션
1장에서는 RxJava에 적용된 리액티브 익스텐션의 개념과 필요성, 그리고 어떤 장점이 있는지 살펴보자.


이 절에서는 리액티브 프로그래밍이 필요한 이유와 리액티브 프로그래밍의 기본적인 형태, 리액티브 익스텍션은 리액티브에 무엇을 더한 것인지, 그리고 RxJava에는 어떻게 적용되는지 살펴보자.

안티패턴도 있음
https://www.slideshare.net/Tomik/practical-rxjava-for-android

// 아래 챕터는 한 단계씩 올림
\chapter{보완할 부분}
- 시점의 복잡함 해결하는 것 설명
- null을 리턴하는 것도 
- fromFuture cancel 안 되는 거?
- disposed 체크하고 dipose 하는 것...
- create에서 onComplete에서 dipose 해버린다.


\chapter{리액티브 익스텐션}

<노트>
Complexity kills. 오라일리의 Reactive Programming With RxJava(RxJava를 활용한 리액티브 프로그래밍, 인사이트 역)의 머리말에 Ray Ozzie의 말이 언급되었다. 목적어가 없는 이 문장은 바로 목적어가 너무나 당연해서 뺀 것이다. 목적어는 바로 개발자인 우리들(us)이다. ‘복잡성은 우리를 죽인다’가 직역이고 ‘복잡성 때문에 죽을 지경이다’가 의역이고 더 나아가면 ‘복잡성은 진짜 지랄맞다’가 우리말 어감에 잘 맞는 표현이 될 것 같다.
</노트>

[주석]필자는 번역 리뷰에 참가해서 관련한 논의에 참여한 바 있다.


https://tylermcginnis.com/imperative-vs-declarative-programming/

http://spiral-architect.pl/2016/03/21/is-reactive-similar-to-event-driven-architecture/

https://stackoverflow.com/questions/34495117/how-is-reactive-programming-different-than-event-driven-programming

http://www.introtorx.com/content/v1.0.10621.0/01_WhyRx.html

IO 에서 스트림이라는 용어가 쓰인다.
이벤트는 지나가면 끝이다. 단명한다. 이벤트를 저장해서 리플레이할 수도 있다.

스트림 용어
http://www.ktword.co.kr/abbr_view.php?m_temp1=1311
http://sculove.github.io/blog/2016/06/22/Reactive-Programming/

이벤트 스트림 프로세싱
이벤트를 listen, 상태 업데이트 또는 db 저장, 다른 이벤트 생성

Event streams capture a sequence of input events such as mouse click, touch movement, or signal updates.

\section{리액티브 프로그래밍}
proactive vs reactive
http://blog.danlew.net/2017/07/27/an-introduction-to-functional-reactive-programming/

리액티브 라이브러리
https://github.com/schlangster/cpp.react

https://en.wikipedia.org/wiki/Reactive_programming
https://codewords.recurse.com/issues/two/an-introduction-to-reactive-programming
http://www.uwanttolearn.com/android/functional-interfaces-functional-programming-and-lambda-expressions-reactive-programming-android-rxjava2-what-the-hell-is-this-part3/

스트림에 대한  얘기도 있음..
https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
이벤트 간의 상호 의존

그런데 넘어서기 힘든 높은 벽이 되어서 복잡성이 버티고 서는 시점이 생긴다.

실세계와 닮았다.
전화를 받고, 알림이 오고

https://www.sas.com/en_us/insights/articles/big-data/3-things-about-event-stream-processing.html

https://www.infoq.com/news/2017/09/events-streaming-kafka

빌드가 오래 걸린다고 할 때, 중간 중간 확인할 것인가? 빌드가 끝나면 노티가 오도록 할 것인가?

이벤트로 본다. 
Collection은 하나의 이벤트일 수도 있고 각각이 처리해야 할 이벤트일 수도 있다.

멀티 코어 CPU가 당연해지면서 CPU를 최대한 활용하기 위해서 비동기로 동작하는 게  많아졌고, 안드로이드에서는 특히 메인 스레드를 블로킹 하지 않도록 UI를 변경하는 코드가 아니라면 비동기로 동작하는 것이 권장된다.

스트림?
https://brunch.co.kr/@oemilk/79

\subsection{왜 리액티브인가}

\subsection{이벤트/이벤트 스트림}
https://www.tibco.com/blog/2010/03/12/events-versus-data/
% 내용 정정 필요
데이터가 변화하고 이를 전달하는 의미로 데이터라는 용어를 사용하는데, 실제에서는 데이터가 변화하지 않아도 이에 대해 반응해야 하는 경우가 많다. 

컴퓨터가 하는 일은 항상 데이터를 변화시킨다. 여러 변수를 변화시키고 영속적인 값을 위해 DB나 파일에 저장하기도 한다. 화면에서 버튼을 클릭하는 경우도 내부적으로 터치 위치 등 일시적인 데이터가 있다. 데이터 변화와 전혀 상관 없을 거 같은 Thread.sleep()도 내부에서 시간을 체크하기 위한 데이터 변화가 있다. 그런데 이런 데이터 변화를 항상 전달 받을 필요가 있는가는 다른 문제이다. 작업을 하긴 하는데 내부적으로만 사용하는 데이터가 있다면 이 데이터가 다른 작업의 기초 데이터로 전달될 수 없다. 즉 이때는 작업이 끝났다고 알려주는 것만으로 충분하다. 바로 이벤트라는 용어가 더 많이 사용되는 이유이다. 데이터가 전달된다면 데이터도 이벤트이고 데이터가 전달되지 않아도 알림이 필요한 것은 이벤트로 간주한다. 

비유하자면 눈앞에 있는 큰 코끼리를 한번에 다 볼 수는 없고 일부분씩 보는 것이다. 코끼리와 같이.. 
이것은 FileInputStream에서 1바이트씩 읽어들이거나 몇 바이트 단위로 읽어들이는 것과도 비슷하다.


https://stackoverflow.com/questions/29787684/java-8-stream-vs-collection-storage

http://www.baeldung.com/java-inifinite-streams

[주석] 중국의 어느 지방에서는 둑을 지울 때 옆에 추가로 물이 흐를 수 있는 하천을 만든다고 한다. 기술의 발전이나 합리성 여부와 상관없이, 물이 넘치지 않게 조절하는 가능한 방법인 듯 하다.

\subsection{리액티브 라이브러리}

\section{ReactiveX}
http://reactivex.io/documentation/operators.html

역사
http://huns.me/development/2051

개념
https://archive.codeplex.com/?p=rx

LINQ
https://academy.realm.io/kr/posts/rxandroid/

Rx = Observables + LINQ + Schedulers

LINQ
https://docs.microsoft.com/ko-kr/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq

https://en.wikipedia.org/wiki/Reactive_extensions

FRP 내용이 필요한가?

\subsection{옵서버 패턴}
http://reactivex.io/documentation/contract.html

Observer 패턴을 적용한 것이다.
https://en.wikipedia.org/wiki/Observer_pattern

http://reactivex.io/intro.html
https://msdn.microsoft.com/en-us/library/hh242985(v=vs.103).aspx

정형화된 콜백이다.
Pull 방식이 아닌 Push 방식 구독

Observable은 아이템 또는 아이템 시퀀스를 내보낸다.
emit, emission

이벤트는 onNext, onError, onComplete를 주로 얘기한다.

예를 들어 EditText에서 addTextChangedListener() 메서드에 전달되는 TextWatcher 인터페이스를 보면 afterTextChanged(), beforeTextChanged(), onTextChanged()와 같이 세 개의 콜백 메서드가 있다. 이때는 세 가지 이벤트로 각각 구분

주로 관찰자를 래핑하고 이벤트 메서드 직접 호출
\subsection{Iterable의 쌍대}

Observable, 연산자, 구독자가 세 축이다.
Observable은 이벤트 개수



android.widget.Checkable, java.io.Serializable
android.graphics.drawable.Animatable
java.lang.AutoCloseable, java.lang.Appendable, 
java.util.concurrent.Callable,

java.lang.Comparable

java.io.Externalizable, 
android.graphics.drawable

java.lang.Iterable
	android.database.Observable
		java.util.Observable
		
java.lang.Runnable
android.os.Parcelable

java.lang.Readable

android.text.Spannable
	java.lang.Throwable

\subsection{함수형 프로그래밍}
http://iloveulhj.github.io/posts/java/java-stream-api.html

람다
https://skyoo2003.github.io/post/2016/11/09/java8-lambda-expression

부작용 얘기
원문: http://blog.jenkster.com/2015/12/what-is-functional-programming.html
번역문: 
https://medium.com/@jooyunghan/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-fab4e960d263

정의부터...
https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0

% 선언형으로 가는 길에 functional progrmming이 있다.

예를 들어 ClassA.method1()  ClassB.method2()  ClassC.method3()  ClassD.method4() 이런 식으로 메서드가 호출되고 앞의 호출은 뒤에서 리턴되는 결과인 SomeResult를 받아서 이를 변경한다고 해보자. 데이터베이스에서 값을 조회하고 비즈니스 데이터와 조합해서 UI에 보여줘야 할 때 이런 식의 메서드 호출은 흔하다. SomeResult의 변수 a, b, c, d, e, f 가운데서 method4()에서는 d, e, f에 값을 넣고 method3()에서는 c에 값을 넣고 method2()에서는 b에 값을 넣고 method1()에서 a에 값을 넣는다. 이와 같이 여러 레이어에 걸쳐서 값이 변경되면 개발자 입장에서 값이 어디서 변경되는지 매번 기억하고 찾는데 어려움이 발생한다. 그리고 또 다른 문제도 생기는 데 바로 ‘스레드 안전한가(thread safe)’의 문제이다. SomeResult 인스턴스 1개가 여러 레이어에 걸쳐서 사용된다면 여러 스레드가 접근할 때 값이 오염될 가능성이 생긴다. 채팅이나 메일과 같은 애플리케이션에서 다른 사용자의 메시지나 메일이 보인다는 얘기를 들은 적이 있을 것이다. 이와 같은 스레드 문제는 개발자 테스트나 QA 테스트에서 잘 나타나지 않기도 하고 문제 발생을 인지한 이후에도 원인을 찾는 게 쉽지 않다. 이때 많이 사용하는 방법이 synchronized 키워드를 쓰는 것인데, 이것도 적용이 간단치 않다. 클래스의 메서드 가운데 어느 일부에만 synchronized 키워드가 있다면 문제 가능성이 남아있...
======
함수형 프로그래밍 언어(Common Lisp, Erlang, Haskell, Clojure 등) 뿐 아니라 함수형 스타일을 적용한 언어(C++, Java, C# 등)도 많아져서 함수형 프로그래밍은 크게 유행한다고 볼 수 있다. 과거에는 학계에서나 관심을 받던 패러다임이 밖으로 나오게 된 데는 컴퓨팅 파워가 비약적으로 발전한 것에 기인한다. 

자바로 개발할 때 가능하면 속도와 효율적인 메모리 사용을 위해 객체 생성을 최소한으로 하라는 규칙도 있고, 스레드 세이프를 위해 데이터를 가능하면 불변(immutable)을 유지하라는 규칙도 있다. 그런데 이 두 가지 규칙은 상충될 때가 많다. 채팅이나 메일과 같은 애플리케이션에서 다른 사용자의 메시지나 메일이 보인다는 얘기를 들은 적이 있을 것이다. 이와 같은 스레드 문제는 개발자 테스트나 QA 테스트에서 잘 나타나지 않기도 하고 문제 발생을 인지한 이후에도 원인을 찾는 게 쉽지 않다. 이때 사용하는 방법이 2가지이다. 첫번째로 synchronized 키워드를 쓰는 것인데, 이것도 적용이 간단치 않다. 클래스의 메서드 가운데 어느 일부에만 synchronized 키워드가 있다면 문제 가능성이 남아있고 synchronized는 다시 속도에 악영향을 미치기도 한다. 두번째 방법이 불변을 유지하기 위해 복사 생성자를 써서 기존에 있던 값을 복사해서 매번 새로운 인스턴스를 만드는 것이다.

값을 공유하고 스레드 세이프하게 유지하는 비용과 ….

자바에서
elapsed 1=8
elapsed 1=47

안드로이드에서
03-08 05:01:44.428 I/System.out(13229): elapsed 1=22962
03-08 05:01:58.007 I/System.out(13229): elapsed 2=13579

build\intermediates\classes\debug\
바이트 코드 보기 javap -c xxx.class

하위 호환을 위한 desugar
https://developer.android.com/studio/write/java8-support.html

이것 때문에 어렵다.
https://softwareengineering.stackexchange.com/questions/209517/why-is-imperative-programming-preferred-over-functional-programming

함수형 인터페이스
http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7766426

라인수가 적어도 이해하기 쉽지 않다. 짧고 표현력이 있지만..
https://softwareengineering.stackexchange.com/questions/158715/are-small-amounts-of-functional-programming-understandable-by-non-fp-people/158721#158721

Imperative programming – defines computation as statements that change a program state.

Declarative programming – defines program logic, but not detailed control flow.

Functional programming – treats programs as evaluating mathematical functions and avoids state and mutable data

Event-driven programming – program control flow is determined by events, such as sensor inputs or user actions (mouse clicks, key presses) or messages from other programs or threads.

컴퓨팅 자원이 무한하다면 속도는 동일하다?
자바 스크립트가 대표적... 오히려 객체를 쓰는 게 적다..

함수형 언어가 있고 함수형 스타일을 지원하는 언어가 있다.

Fure Function, High order function

SAM
인터페이스나 함수나 동격이다. 함수가 하나밖에 없기 때문에.
인터페이스는 감싸는 역할 뿐

함수형 프로그래밍 & 순수 함수
https://en.wikipedia.org/wiki/Functional_programming
https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98%ED%98%95_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D

리턴이 없는 것은 기본적으로 사이드 이펙트가 있다는 말이다.

고차 함수 정의
https://ko.wikipedia.org/wiki/%EA%B3%A0%EC%B0%A8_%ED%95%A8%EC%88%98

Lazy evaluation is one of them, and it may take months before one starts to understand why lazy evaluation is an excellent feature, and not an annoyance.(?)

For example, I consider writing pure functions to be extremely important for any software written in any language (where by "pure" I mean no side-effects), because:

they're easier to unit test
they're much more composable than side-effecting functions
they're easier to debug
I also often avoid mutating values and variables -- another concept borrowed from FP.

Now about functional programming. I think that the major benefits are:
- Closer alignment to mathematical thinking; you tend to spell out your ideas in a format close to mathematical definitions rather than iterative programs.
- No (or at least fewer) side-effects: your functions do not influence other functions, which is great for concurrency and parallelization, but also for debugging.
- Fewer lines of code, without sacrificing conceptual clarity: Lisp is more powerful than non-functional languages, in a similar way as C++ is more powerful than Assembler. You spend a greater proportion of your project with thinking than writing, but eventually, you will probably find that you are more productive (get more features done in less time). Also, fewer LOC means easier maintenance.


단점? 다른 내용도 있다.
https://alvinalexander.com/scala/fp-book/disadvantages-of-functional-programming

제네릭에 대한 이해도 필요하다.
PECS(producer extends consumer super)
파라미터에 T가 전달되는 경우는 consumer
예) List.add(..)

% 프리젠테이션에 표로 있음

https://github.com/akarnokd/RxJava2Extensions
RxJava1에 있던 Action3~Action9를 대체하는 Consumer3~Consumer9  제공한다.

메서드가 하나 밖에 없는 인터페이스이다.
이는 람다 표현식으로 쓸 수 있다.
Runnable, Callable, Comparable이 그 예이다.
자바 8에 추가된 것들이 많은데 rxjava에도 들어가 있다
모두 throws Exception을 하고 있다. 그래서 대체가 되지 않는다.

람다를 쓰는 덕분에 Observable, Single 을 쓰는 차이가 별로 느껴지지 않는다.

% http://multifrontgarden.tistory.com/125

안드로이드 스튜디오 3에서는 build.gradle에 아래 옵션만 추가하면 된다.
\begin{verbatim}
android {
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
\end{verbatim}

\begin{comment}
% retrolamdba는 굳이 필요하지 않은 것 같다.
Java8을 지원하면 내용이 제거되니 지금은 대강만 쓰자.
자바 8부터 지원하는 람다식을 쓸 수 있다.
안드로이드 스튜디오에서 사용방법은 https://github.com/evant/gradle-retrolambda를 참고하자.
\end{comment}

\subsection{리액티브 라이브러리}

\section{ReactiveX 계약}
실제 프로그램에서는 여러가지 이벤트가 동시에 발생하는데 어떻게 하나씩 소비된다는 말일까? 바로 이벤트 종류별로 스트림이 별도이다. 특정 버튼 클릭 이벤트를 동시에 발생시키지 못하는 것을 생각해보자. 

질문이 또 있을 수 있다. 스레드에서 동시 발생되는 이벤트가 있다면 어떨까? 이는 ?절에서 얘기하는 ReactiveX 규약에서 동시 발생 이벤트는 권장하지 않는다. 빠뜨려지는 이벤트가 있으면 이벤트를 제대로 처리할 수 없는 것이다.


규칙을 이해해야 한다. 이후에 얘기하는 것도 관련
http://reactivex.io/documentation/contract.html에 Rx Design 가이드라인
% 여기서 Rx Design Guidelines 문서도 다운받을 수 있다.

\subsection{Observable과 Observer 간의 통신}
reactive pull
https://github.com/Froussios/Intro-To-RxJava/blob/master/Part%204%20-%20Concurrency/4.%20Backpressure.md

\subsection{이벤트 순서와 횟수}
유한 이벤트에서 종료 이벤트를 쓰지 않는 건 어떨까? Observable에서 몇 개의 onNext 이벤트를 발생시키고 onComple나 onError가 없는 경우이다.

\subsection{종료 이벤트는 이벤트 스트림을 종료시킴}

\subsection{null 데이터 허용 안됨}

\subsection{Observable은 Observer에 순차적으로 이벤트를 전달해야 함}

\section{RxJava}
% 뒤에 어디를 참고하라는 내용을 말하도록 하자.
RxJava를 모든 경우에 사용하는 게 정답은 아니다.
오히려 복잡해지는 경우도 있다.

RxAndroid에 대해서 개념이 부족한 경우가 있다. 일반적으로 아래 패키지를 지칭한다.

https://github.com/ReactiveX/RxAndroid

본래는 라이프 사이클 등까지 있었다.


compile 'io.reactivex:rxandroid:1.2.1' 



https://github.com/trello/RxLifecycle
https://github.com/JakeWharton/RxBinding

https://github.com/ReactiveX/RxAndroid/wiki 이 페이지를 참고하자.

\chapter{안드로이드에 적용}
\section{AsyncTask 대안}
\subsection{예외를 처리하는 메서드 없음}


\subsection{동시에 결과 적용}
CountDownLatch를 사용해왔다.

ConcurrentModificationException이 발생했었는데? 이상하다..
concatEager는 하위로 보낼 때 하나씩 onNext가 끝날 때까지 기다린다.

        Observable.concatEager(bookObservables) // (1)
            .scan((total, chunk) -> { // (3) 시작
                System.out.println("start=" + System.currentTimeMillis() + ", " + chunk.toString()
                + "," + Thread.currentThread().getName());
                SystemClock.sleep(5000);
                total.addAll(chunk);
                System.out.println("end=" + System.currentTimeMillis());
                return total;
            }) // (3) 끝
            

\section{콜백 중첩 문제}
https://teamtreehouse.com/community/callbacks-vs-event-handlers
https://ko.wikipedia.org/wiki/%EC%BD%9C%EB%B0%B1
% 날씨 구하기
http://blog.naver.com/PostView.nhn?blogId=2hyoin&logNo=220398943180

\section{UI 반복 변경}

\section{순차 API 호출}
음성 TTS
여러 개 약관

순서가 중요한 메서드 호출
API는 호출 순서가 중요한 때가 있다. 필자는 과거에 회사 동료가 페이스북 SDK를 사용해서 연동하는 걸 옆에서 본 적이 있었는데 연동 작업에 꽤 애먹는 것을 본 적이 있다. 결국 작업이 성공했을때 동료의 결론은 호출 순서가 중요하다는 것이었다. if 문에 따른 여러 실행 경로가 있고 서버에 먼저 전송해야 할 필수 데이터가 있다면 누가 하더라도 만만치 않은 작업이었을 것이다. 현재의 페이스북 SDK는 과거만큼 복잡해보이지는 않아서 그나마 다행인데, 어쨌든 이와 같이 순서가 중요한 작업들은 어디서나 존재한다. 

네이버 오픈 API에 보면 TTS 기능이 있다[주석]. 이 기능은 텍스트를 서버에 전송하면 서버에서 응답으로 mp3 파일을 생성해주는 것이다.

[주석] https://developers.naver.com/docs/clova/api/CSS/API_Guide.md#UsingAPI 서비스 구분에 따라서 URL은 변경 가능성이 있다. URL이 달라졌다면 우상단의 검색 기능을 활용해보자.


\section{상호 참조 제거}
ListView 의 ListAdapter 에 ListView 를 전달하는 것을 보기도 했다.
Activity를 전달한 적이 있다.

% +/- 버튼

이는 할리우드 원칙[주석]으로도 불리는데  "내가 전화할테니 너는 전화하지마"이다.
[주석] Head First Design Patterns 8장을 참고하자.

http://wiki.c2.com/?HollywoodPrinciple

느슨한 결합
http://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS7222611536

고수준 구성 요소, 저수준 구성 요소
https://en.wikipedia.org/wiki/High-_and_low-level

\section{리스너 인터페이스 대체}
프래그먼트에서 이벤트 전달 받기
액티비티에서 프래그먼트를 포함하기도 하고 프래그먼트 내에서 또 프래그먼트를 포함하기도 하는데 프래그먼트에서도 액티비티나 부모 프래그먼트에 이벤트 전달이 필요할 때가 많다.

프래그먼트의 특징으로 액티비티에 모든 뷰를 넣지 않고 여러 곳에 재사용할 수 있다고 하는데 

\section{선언적 예외 처리}
%DataFormatter 예제
Base64 encode, decode 예제도?
https://www.slipp.net/questions/350

""을 리턴하는 것도 포함

\section{반복문 대체}
https://developer.android.com/guide/practices/verifying-apps-art#Stack_Size

\chapter{Observable과 Observer}
\section{리액티브 타입}
\section{Observable 생성 연산자}
\section{Observer}
https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87

\section{구독, 구독 해제}

\chapter{RxJava 기본}



구독/구독 제거
연산자
- 퓨전 모드
멀티 캐스트

타입간 변환은 리액티브 타입 그 다음으로?

\section{클래스 구성}
Observable과 배압을 고려한 Flowable이 있다.

\subsubsection{스트림}

\subsubsection{구독}
왜 observer가 아닌가?

점대점, 발행구독
https://community.boomi.com/docs/DOC-1666

발행자는 구독자를 모른다. 구독자가 없을 수도 있다.

Observer 패턴은 점대점이다. 

https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c

https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern

Lambda Observer onNext에서 onError 호출

onError 이벤트는 Observable에서 에러가 발생할 때 보내는 이벤트이다. 그런데 Observer에서 onNext 이벤트를 소비하는 과정에서도 에러가 발생할 수 있는데 이 때도 onError 이벤트로 


\subsubsection{Subject}

\section{리액티브 타입}
\subsection{Observable}
cast는 Observable에만 있다.

% https://github.com/ReactiveX/RxJava/wiki/Creating-Observables

Observable.fromArray(1, 2, 3, null).subscribe(System.out::println);
\begin{verbatim}
Exception in thread "main" io.reactivex.exceptions.OnErrorNotImplementedException: The 3th element is null
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)
	at io.reactivex.internal.observers.LambdaObserver.onError(LambdaObserver.java:74)
	at io.reactivex.internal.operators.observable.ObservableFromArray$FromArrayDisposable.run(ObservableFromArray.java:104)
	at io.reactivex.internal.operators.observable.ObservableFromArray.subscribeActual(ObservableFromArray.java:36)
	...
\end{verbatim}




Observervable은 subscribe() 메서드에 Observer를 받는다.

\begin{verbatim}
public interface Observer<T> {

    void onSubscribe(@NonNull Disposable d);

    void onNext(@NonNull T t);

    void onError(@NonNull Throwable e);

    void onComplete();

}
\end{verbatim}

LambdaObserver가 주로 사용된다.
onNext에서 에러가 발생하면 onError를 호출한다.
onError나 onComplete
LambdaObserver는 DisposableObserver를 상속한 것은 아니다
% 소스 넣기

onSubscribe() 메서드는 실제 사용할 일이 없다.
퓨전 모드, Disposable

toFlowable 메서드는 있다.
toMaybe나 toSingle, toCompletable 같은 메서드는 없다.

RxJavaPlugins에 errorHandler를 지정할 필요도 있다. onError에서도 Throwable을 보낼 때도 있다.

\subsection{Flowable}
Observable과 구독자 사이는 배압 고려

\begin{verbatim}
public interface Subscriber<T> {

    public void onSubscribe(Subscription s);

    public void onNext(T t);

    public void onError(Throwable t);

    public void onComplete();
} 
\end{verbatim}

\subsection{Maybe}

\subsection{Single}

\subsection{Completable}

\subsection{타입 간 변환}
명시적으로 변환하는 메서드가 있고, 묵시적으로 변환하기도 한다.
% 표를 만들어야 한다. 워드로 작성하자.

\section{연산자}
세가지 분류를 가진다. Observable에 연결할 수 있는 메서드를 모두 가리킨다.
https://academy.realm.io/posts/gotocph-jake-wharton-exploring-rxjava2-android/

Manipulate or combine data in some way.
Maniuplate threading in some way.
Maniuplate emissions in some way.

문서에 따라 Observable을 생성하는 메서드라 구독 메서드도 연산자에 포함시키기도 한다.
http://reactivex.io/documentation/operators.html
여기서는 구분을 하도록 하겠다.
io.reactivex.internal.operators에는 생성과 변환을 모두 포함한다.
어차피 만드는 것이다!!

Observable 생성
구독

\subsection{체인}
Observable 체인, Observer 체인, operator 체인


\section{구독/구독 제거}
subscribe에는 Observer가 전달된다. 그런데 Observer를 그냥 쓰면 문제가 발생할 수 있다.
아래 코드를 보자.
\begin{verbatim}
	List<Integer> list = Arrays.asList(1, 2, 3, 4);
	Observer<Integer> observer = new Observer<Integer>() {

		@Override
		public void onSubscribe(Disposable d) {
		}

		@Override
		public void onNext(Integer value) {
			System.out.println("value=" + value);
		}

		@Override
		public void onError(Throwable e) {
			e.printStackTrace();
		}

		@Override
		public void onComplete() {
			System.out.println("onComplete");
		}

	};
	Observable.fromIterable(list)
			.filter(x -> x > 2)  // (1)
			.map(x -> x + 5) // (2)
			.subscribe(observer);  // (3)
	observer.onNext(77); // (4)		
\end{verbatim}
(1)에서 3, 4가 다운스트림에 전달되고 (2)에서 5가 더해져서 observer에 전달돼서 5, 9가 출력된다.
그런데 (4)는 어떤 동작을 할까? 
직접 호출을 하기 때문에 당연히 출력이 된다.
종료 상태에서는 호출이 안 되어야 하기 때문에 규칙 위반이다.


\subsection{구독 제거}
unregisterReceiver, setOnClickListener(null), setOnLongClickListener(null) 등 여러가지가 있는데 인터페이스를 동일하게 묶는 효과도 있다.
dispose는 event가 계속 오는 도중에 끝내려는 의도가 있다. onComplete나 onError가 정상적으로 불려서 다 끝난 것은 dipose가 필요하지 않다.
interval 같은 건 반드시 dispose  해야 하는 거고 just 같은 건 필요 없다.

% rage().observeOn은 구독 제거해야 하는가?

\begin{verbatim}
public interface Disposable {

    void dispose();

    boolean isDisposed();
}
\end{verbatim}

위 코드를 보자.
subscribe 가 되면 
ObservableFromIterable.subscribeActual
->ObservableFilter$FilterObserver의 onSubscribe
->ObservableMap$MapObserver의 onSubscribe가 호출된다.

ObservableFilter$FilterObserver의 onSubscribe(Disposable d)에는 
ObservableFromIterable$FromIterableDisposable이 전달된다.
ObservableMap$MapObserver의 onSubscribe()에는 ObservableFilter$FilterObserver가 전달된다.
마지막 Observer에는 ObservableMap$MapObserver가 전달된다.
dispose의 기본 매커니즘은 전달된 Disposable의 dispose를 호출하는 것이다.
따라서 쭉 따라가면 ObservableFromIterable$FromIterableDisposable가  호출된다.
중간의 모든 Observer는 onSubscribe 메서드가 사용되고 Disposable 인터페이스 구현체이다.

 


상속을 해야 하는 문제가 있다? 확인 필요.
https://github.com/trello/RxLifecycle

LamdaObserver를 보면 onError가 불리면 dispose 해버린다.

DisposableObserver, ResourceObserver

% 키노트에 구독 메서드 모음
forEach(Consumer<? super T> onNext)
forEachWhile(Predicate<? super T> onNext)
forEachWhile(Predicate<? super T> onNext, Consumer<? super Throwable> onError)
forEachWhile(final Predicate<? super T> onNext, Consumer<? super Throwable> onError,
            final Action onComplete)

\section{퓨전 모드}
fusion은 사전적으로 '융합, 결합'의 의미를 가진다.
2개 이상의 연속되는 연산자가 time, memory 오버헤드를 줄이는 방식으로 결합되는 것이다.

큐 구조를 공유할 수 있다.
% https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0#operator-fusion
%http://akarnokd.blogspot.kr/2016/03/operator-fusion-part-1.html
%http://akarnokd.blogspot.kr/2016/04/operator-fusion-part-2-final.html
여러 개의 연산자가 하나의 연산자로 합쳐지는 매크로 퓨전과 여러 연산자의 데이터 구조가 공유되는 마이크로 퓨전으로 나뒨다.

매크로 퓨전은 어셈블리 시점에...
ObservableRange에도 있다.
just(T t)와 같은 것..
ScalarCallable가 업스트림이라면 flatMap, concatMap, switchMap 은 간단하게 할 수 있다.

마이크로 퓨전은 주로 구독 시점에..

ConditionalSubscriber 선택적으로 하는 것..
filter, distinct
Flowable에 퓨전 모드가 적용이 많다.
ObservableRange VS FlowableRange
request(1)을 줄이기 위한 것이다.

\begin{verbatim}
public interface QueueFuseable<T> extends SimpleQueue<T> {

    int NONE = 0;

    int SYNC = 1;

    int ASYNC = 2;

    int ANY = SYNC | ASYNC;

    int BOUNDARY = 4;

    int requestFusion(int mode);
    
}    
\end{verbatim}

requestFusion의 파라미터에는 QueueFuseable의 상수값이 들어간다.
SYNC, ASYNC, ANY, SYNC | BOUNDARY, ASYNC | BOUNDARY, ANY | BOUNDARY 값이 들어간다.
리턴값도 마찬가지로 QueueFuseable의 상수이다. 이때는 SYNC, ASYNC만 나온다.
BOUNDARY는 poll이 다른 스레드에서 일어난다는 의미이다. 
호출하는 쪽:
flatMap과 observeOn만 BOUNDARY로 요청한다.
% instanceof QueueDisposable 쓰이는 곳 찾을 것
ObservableConcatMap, ObservableConcatMapCompletable, ObservableConcatMapEager,
flatMap, observeOn, doFinally

% .requestFusion( find
Flowable은 더 많다.
CompletableConcat

transitive(BasicFusableObserver 상속) : transitiveBoundaryFusion
distinct, distinctUntilChanged,doAfterNext, filter, map
BOUNDARY가 있는 경우에는 transitive하지 않는다.



SYNC - fromArray, fromIterable, range, rangeLong, ObservableScalarXMap
소스가 SYNC를 지원하지 않으면?

ASYNC - observeOn, flatMapCompletable, UnicastProcessor, UnicastSubject

wip : work in progress 의미

\section{RxJavaPlugins}
https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/debug/RxJavaAssemblyTracking.java
https://stackoverflow.com/questions/46941843/rxjava-2-assembly-process
https://line.github.io/armeria/xref/com/linecorp/armeria/common/rxjava/RequestContextAssembly.html

\chapter{Observable}
% https://github.com/mgp/effective-rxjava/blob/master/items/understand-observable-and-observer-chains.md
데이터 소스를 이벤트 스트림으로 변경한 것이다.
이벤트 스트림은 아이템 시퀀스로 부르기도 한다.

\section{Observable 생성 연산자}
정적 메스드에서 생성한다.
from, defer, fromCallable, just 비교

List는 전체가 하나의 이벤트 스트림일 수도 있고 각각이 이벤트 일 수도 있다.

\subsection{just}
Observable.just
왜 있을까 궁금했다. 주로 연산자를 연결할 때 사용된다.
flatMap(user -> user.isLoggined? bookmarkRepostiory.getBookmarkList() : Observable.just(new BookmarkList())

https://stackoverflow.com/questions/29169194/why-does-subscribe-not-executed-in-a-new-thread

just는 그 순간에 평가된다.

\subsection{from 시리즈}
fromArray(T... items)
fromIterable(Iterable<? extends T> source)

fromFuture, fromPublisher

\subsubsection{fromCallable}
하나만 리턴한다. 예외에 대한 처리와 dispose 체크가 있다.

Single.fromCallable을 쓰는 게 더 낫겠다.

\subsection{never/empty/error}
Observable.never()는 onComplete를 호출하지 않는다. Observable.empty()와 달리..

\subsection{range}
rangeLong

\subsection{timer}
timer postDelayed()와 비슷

\subsection{interval}

\subsection{intervalRange}



\subsection{create}
create(ObservableOnSubscribe<T> source)

Observable.create
onComplete() 메서드는 넣는 게 낫다. 
하위 스트림에서 onComplete가 불리지 않는다.
onError에 로그만 남기면 안 된다. 스택만 남으면 위치가 파악이 안 된다. 
% isDisposed() 체크가 rxjava2에서는 필요하지 않다.(확인 필요)

ObservableEmitter

\begin{verbatim}
public interface ObservableOnSubscribe<T> {

    void subscribe(@NonNull ObservableEmitter<T> e) throws Exception;
    
}
\end{verbatim}

\begin{verbatim}
public interface Emitter<T> {

    void onNext(@NonNull T value);

    void onError(@NonNull Throwable error);

    void onComplete();
}
\end{verbatim}

\begin{verbatim}
public interface ObservableEmitter<T> extends Emitter<T> {

    void setDisposable(@Nullable Disposable d);

    void setCancellable(@Nullable Cancellable c);

    boolean isDisposed();

    ObservableEmitter<T> serialize();

    @Experimental
    boolean tryOnError(@NonNull Throwable t);
}
\end{verbatim}

\subsection{using}
http://reactivex.io/documentation/operators/using.html

create a disposable resource that has the same lifespan as the Observable

The Using operator is a way you can instruct an Observable to create a resource that exists only during the lifespan of the Observable and is disposed of when the Observable terminates.

using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, Consumer<? super D> disposer)
eager 디폴트는 true

using(Callable<? extends D> resourceSupplier, Function<? super D, ? extends ObservableSource<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager)

리소스 기반으로 Observable을 만들고, Observable이 종료될 때 작업...

subscribe 하는 순간에 리소스를 생성하고 종료될 때 disposer에서 리소스를 전달받아서 정리 작업을 한다.




\subsection{defer}
Observable.defer
기존 코드를 결합할 때 사용한다.
Observable의 장점은 선언만 하고 subscribe를 하는 시점에 Observable의 내용이 실행되는 것이다.


\subsection{using}
https://medium.com/mindorks/rxjava-introduction-to-using-operator-61b5273c1b5b

\subsection{wrap}
wrap(ObservableSource<T> source)

source가 이미 Observable이라면 그대로 리턴하고 아니라면 Observable로 감싸서 리턴한다.
그래봐야 subscribeActual 메서드를 구현한 것 뿐이다.
ObservableSource가 전달되었는데, Observable의 메서드를 호출해야 할 때 필요
내부에서 가끔 쓰이는 연산자이다.
ambArray, compose, concatArray, concatArrayDelayError, concatEager

\subsection{generate}
generate(Callable<S> initialState, final BiConsumer<S, Emitter<T>> generator)

generate(final Callable<S> initialState,
            final BiConsumer<S, Emitter<T>> generator,
            Consumer<? super S> disposeState)

Observable<T> generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator)

generate(Callable<S> initialState, BiFunction<S, Emitter<T>, S> generator,
            Consumer<? super S> disposeState) {

초기값에 따라 Emitter에서 이벤트를 내보낸다.            
disposeState는 최종 상태를 나타낸다.
무한 루프에서 계속 값을 만들어내고 dispose하거나 터미널 상태가 되어야만 루프문이 끝이 난다.
Emitter에서 상태에 따라 onComplete를 호출할 수도 있다.
scan 연산자를 대신 할 수도 있다.

https://stackoverflow.com/questions/37683832/observable-generate-in-rxjava
https://en.wikipedia.org/wiki/Corecursion

% unsafeCreate 굳이 필요 없음

\section{Cold/Hot Observable} 
% https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339
% https://stackoverflow.com/questions/32190445/hot-and-cold-observables-are-there-hot-and-cold-operators
% http://tomstechnicalblog.blogspot.kr/2016/03/rxjava-problem-with-subjects.html
% http://www.introtorx.com/content/v1.0.10621.0/14_HotAndColdObservables.html
적극적인(active), 소극적인(passive)
디폴트 모드가 Cold Obseravble이다.
Cold Observable은 subscribe에서 이벤트를 새로 트리거한다.
https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html
사이드 이펙트를 한번만 나도록 하기 위해서 publish 사용


https://github.com/Froussios/Intro-To-RxJava/blob/master/Part%203%20-%20Taming%20the%20sequence/6.%20Hot%20and%20Cold%20observables.md

% replay 양상에 대해서도 얘기 필요
Hot Observable의 예
마우스 클릭
버튼 클릭
주가
모바일 단말 센서

엄밀하게 얘기해서 Broadcast는 Hot Observable에 해당한다. 

멀티캐스트: 데이터를 여러 사용자에게 동시에 보낸다는 의미
- 이벤트 소스 자체가 Hot한 경우
- Observable을 Hot하게 만드는 게 publish
- Subject

% RxBinding도 얘기해보자. RxLocation도?

\subsection{Subject}
% http://reactivex.io/documentation/subject.html
구독자 목록을 유지한다. LocalBroadcastManager와 비슷
onError나 onComplete 이후에는 onNext가 불리지 않는다.
이는 http://reactivex.io/documentation/contract.html 규약에 의한 것이다.

\subsubsection{PublishSubject}

\subsubsection{BehaviorSubject}

\subsubsection{AsyncSubject}

\subsubsection{AsyncSubject}

\subsubsection{UnicastSubject}
subscribe가 2개 이상 되면 안된다.

\subsection{ConnectableObservable}
% 클래스 다이어그램

\section{replay}
다시 보기, 재현의 의미이다. 양상이 다르다.

\chapter{스케줄러}
% http://www.baeldung.com/rxjava-schedulers
기본적으로 Observable과 Observer는 하나의 동일한 스레드에서 동작한다.

한번에 하나의 이벤트만 내보내는 RxJava 규약에 맞게 동작하도록 되어 있다.
% 오라일리 163p

% Scheduler 클래스 다이어그램

RxJava에서는 선언적으로 스레드를 지정하는 것이 권장된다.

Schedulers에 정적 메서드로 사용 가능한 스케줄러는 아래 4개이다.
Schedulers.newThread()
Schedulers.computation()
Schedulers.io()
Schedulers.single()
Schedulers.trampoline()

그리고 사용자가 만든 Executor로 Scheduler를 만들 수도 있다.
Schedulers.from(@NonNull Executor executor)

TestScheduler

Scheduler와 내부 클래스인 Scheduler.Worker의 주요 메서드를 보자.
\begin{verbatim}
abstract class Scheduler {

    abstract Worker createWorker();

    long now(@NonNull TimeUnit unit);

    Disposable scheduleDirect(@NonNull Runnable run);
    
    Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);

    Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit);
    
    abstract static class Worker implements Disposable {
        
        Disposable schedule(@NonNull Runnable run);

       
        abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);

        Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit);

        long now(@NonNull TimeUnit unit);

}
\end{verbatim}
% Scheduler에는 start()와 shutdown() 메서드도 있는데 각 Schduler에서 내부적으로 사용하는 메서드이다. 퍼블릭 메서드지만 호출하면 안 될 것 같다.

Scheduler와 Worker에 schedulerDirect()와 schedulePeriodicallyDirect()가 동일하게 있는 게 보인다.
now() 메서드는 Scheduler와 Scheduler.Worker에서 내용이 중복되는 코드이다. 
Scheduler의 now() 메서드는 여러 연산자에서 시간을 체크할 때 사용한다.
Scheduler.Worker의 now() 메서드는 Scheduler.Worker내의 schedule(), schedulePeriodically 메서드에서 시간을 체크할 때 사용하다.
이 메서드가 오버라이드 가능한 이유도 있다. 바로 가상화된 시간을 제공하는 것이다.
시간에 의존성이 있는 작업이 있다고 하자. 이를테면 1분 후에 API를 호출해서 ~하는 것이다.
% 사용시간 체크?
TestScheduler에서 advanceTimeBy(long delayTime, TimeUnit unit), advanceTimeTo(long delayTime, TimeUnit unit) 메서드로 가상 시간을 변경할 수 있다.

좀 더 자세한 내용은 TestScheduler 절을 참고하자.

ObservableSubscribeOn의 subscribeActual() 메서드는 아래와 같다.
\begin{verbatim}
    @Override
    public void subscribeActual(final Observer<? super T> s) {
        final SubscribeOnObserver<T> parent = new SubscribeOnObserver<T>(s);

        s.onSubscribe(parent);

        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
    }
\end{verbatim}

observeOn(Scheduler scheduler)
observeOn(Scheduler scheduler, boolean delayError)
observeOn(Scheduler scheduler, boolean delayError, int bufferSize)

업스트림에서 onNext에 전달된 값은 큐에 저장하고 스레드에서 무한반복문에서 큐에서 꺼내서 순차적으로 이벤트를 만들어 낸다.
무한반복문이 끝나려면 dispose가 되어야 한다.
ObservableObserveOn의 subscribeActual() 메서드는 아래와 같다.
\begin{verbatim}


    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        if (scheduler instanceof TrampolineScheduler) {
            source.subscribe(observer);
        } else {
            Scheduler.Worker w = scheduler.createWorker();

            source.subscribe(new ObserveOnObserver<T>(observer, w, delayError, bufferSize));
        }
    }
\end{verbatim}

unsubscribeOn

schduledThreadPool 최대 개수는 core와 동일하다.

선언적 스케줄링
computation은 이벤트 루프 방식

자동 완성 테스트 샘플
Scheduler를 변경해야 한다.
sample에서 Scheduler.io() 필요하다.

trampoline을 제외하고 모두다 ScheduledThreadPoolExecutor를 사용한다.

Schedulers.from(Executor executor) 메서드를 사용할 때도 만일 전달된 파라미터가 ScheduledExecutorService일 때는
그대로 사용하고 아니면 Schedulers.single()을 이용해서 schedule을 실행한다.

trampoline은 schedule 시에 직접 sleep을 사용한다.

\section{computation Scheduler}
최대 스레드 개수가 Runtime.getRuntime().availableProcessors()로 되어 있다.
rx2.computation-threads 시스템 프로퍼티로 더 적게 세팅할 수는 있다.
% 권한 문제 체크 필요


io.reactivex.internal.schedulers.ComputationScheduler 클래스에 지정

디폴트로 computation 스케줄러로 되어 있는 것들은 아래와 같다.  오버로딩된 
메서드가 있어서 다른 스케줄러를 사용할 수도 있다.
buffer(), debounce(), delay(), delaySubscription(),
interval(), intervalRange(), 
replay(), sample(), throttleFirst(), timeInterval(), timeout(), timestamp(), window(), 
timer()


\section{io Scheduler}
keepAlive시간 60초
ConcurrentLinkedQueue에 각각 ScheduledThreadPool을 유지한다.

\section{트램펄린 스케줄러}
Trampoline Scheduler는 실행되는 스레드에서 큐 구조를 만든 것 뿐이다.

trampoline 스케줄러를 사용하는 메서드는 아래와 같다.
skipLast(), takeLast()

\begin{verbatim}
Observable.interval(1, TimeUnit.SECONDS).observeOn(Schedulers.trampoline())
	.subscribe(value -> title.setText("val=" + value + ", Thread=" + 		Thread.currentThread().getName()));
\end{verbatim}

이것은 크래시를 발생시킨다.

\begin{verbatim}
public void onClickButton2(View view) {
	Observable.interval(1, TimeUnit.SECONDS).observeOn(Schedulers.trampoline())
	.map(value -> String.valueOf(value))
	.subscribe(this::printInThread);
}

private void printInThread(String input) {
SystemClock.sleep(2000);
System.out.println(input + "Thread " + Thread.currentThread().getName());
}
\end{verbatim}

\section{subscribeOn/observeOn}


\chapter{주요 연산자}

fusable 한 연산자는 5개가 있다.
내부 Observer가 BasicFuseableObserver 상속
filter(), map(), distinct(), distinctUntilChanged(), doAfterNext()이다.

\section{필터링}
아이템 시퀀스의 일부만 하위 스트림에 전달할 때 사용한다.
% ?? 절의 스로틀도 여기에 포함될 수 있다.
\subsection{filter}
filter(Predicate<? super T> predicate)

ofType 연산자도 있다.

\subsection{distinct/distinctUntilChanged}
\subsubsection{distinct}
버퍼에 저장한다.
distinct()
distinct(Function<? super T, K> keySelector)
distinct(Function<? super T, K> keySelector, Callable<? extends Collection<? super K>> collectionSupplier)

\subsubsection{distinctUntilChanged}
distinctUntilChanged()
distinctUntilChanged(Function<? super T, K> keySelector)
distinctUntilChanged(BiPredicate<? super T, ? super T> comparer)

\subsection{take 시리즈}

시작부터 이벤트 개수나 시간을 제한하는 방법을 제공한다.
% 표로 하는 게 나을 듯
take(long count)
개수를 제한한다.
take(long time, TimeUnit unit)
take(long time, TimeUnit unit, Scheduler scheduler)
디폴트 스케줄러는 computation 스케줄러이다.



takeLast(int count)
takeLast(long count, long time, TimeUnit unit)
takeLast(long count, long time, TimeUnit unit, Scheduler scheduler)
takeLast(long count, long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize)
takeLast(long time, TimeUnit unit)
takeLast(long time, TimeUnit unit, boolean delayError)
takeLast(long time, TimeUnit unit, Scheduler scheduler)

takeUntil(ObservableSource<U> other)

takeUntil(Predicate<? super T> stopPredicate)
takeWhile(Predicate<? super T> predicate)

takeUntil(searchObs) // (1) 그 순간에 subscribe 되기 때문에 아래로 전달되지 않는다. takeUntil은 Hot Observable에 적합?


\subsection{skip 시리즈}
skip(long count)
skip(long time, TimeUnit unit)
skip(long time, TimeUnit unit, Scheduler scheduler)
skipLast(int count)
skipLast(long time, TimeUnit unit)
skipLast(long time, TimeUnit unit, boolean delayError)
skipWhile(Predicate<? super T> predicate)

\subsection{timeout}
emission간에 타임아웃을 줄 수 있다.
다른 Observable에서 유효한 시간을 정할 수도 있다. 
첫번째 것은 timeout 되지 않는다.

timeout(long timeout, TimeUnit timeUnit)
timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler)
timeout(long timeout, TimeUnit timeUnit, ObservableSource<? extends T> other)
timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, ObservableSource<? extends T> other)
timeout(Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator)
timeout(Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator,
            ObservableSource<? extends T> other)

timeout(ObservableSource<U> firstTimeoutIndicator,
            Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator)
timeout(ObservableSource<U> firstTimeoutIndicator,
            Function<? super T, ? extends ObservableSource<V>> itemTimeoutIndicator,
                    ObservableSource<? extends T> other)                        

\subsection{element 시리즈}
\subsubsection{elementAt}
Maybe<T> elementAt(long index)
Single<T> elementAt(long index, T defaultItem)
Single<T> elementAtOrError(long index)

\subsubsection{firstElement}
내부적으로 elementAt(0)을 호출한다. 

\subsubsection{lastElement}
Maybe<T> lastElement()
업스트림에서 onComplete가 불리는 시점에 onNext가 불린다. 

\subsubsection{singleElement}
Maybe<T> singleElement()
Observable이 2개 이상을 내보내면 IllegalArgumentException을 onError에 전달한다.

\subsubsection{ignoreElements}
Completable ignoreElements()

\subsection{first/last}
Single<T> first(T defaultItem) 
elementAt(0L, defaultItem) 호출한다.

Single<T> firstOrError()
elementAtOrError(0L) 호출한다.

Single<T> last(T defaultItem)

Single<T> lastOrError()

\subsection{single}
Single<T> single(T defaultItem)
아니템을 2개 이상 내보낸다면 IllegalArgumentException을 onError에 전달한다.

Single<T> singleOrError()

\section{아이템 변환}
\subsection{map}
타입이 변경될 수 있다.



\subsection{cast}

\subsection{materialize/dematerialize}

\subsection{timestamp/timeInterval}
Observable<Timed<T>>를 리턴한다.

timeInterval은 이벤트 사이의 간격이 전달된다.

\subsection{scan}
훓어보다, 유심히 살피다는 의미이다.

scan(BiFunction<T, T, T> accumulator)
scan(final R initialValue, BiFunction<R, ? super T, R> accumulator)

scanWith(Callable<R> seedSupplier, BiFunction<R, ? super T, R> accumulator)
zipWith 등 다른 것과 달리 첫번째에 Observable이 들어가지 않고 Callable이 들어간다.

\section{아이템 순서 변경}
\subsection{sorted}





\subsection{repeat}
repeatUntil
repeatWhen


\section{단일 아이템으로 변경}
리턴은 Single 또는  Mayb e이다.

\subsection{Boolean 타입}       
Single<Boolean>을 리턴한다.           
\subsubsection{all}
all(Predicate<? super T> predicate)

\subsubsection{any}

\subsubsection{contains}
contains

\subsubsection{isEmpty}
all(Functions.alwaysFalse());

\subsubsection{sequenceEqual}

sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2)
sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
            BiPredicate<? super T, ? super T> isEqual)
            sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
            int bufferSize)
sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2,
            BiPredicate<? super T, ? super T> isEqual, int bufferSize)

\subsection{컬렉션 타입}
collect
collectInto
toList()
toMap
toMultimap
toSortedList

\subsection{기타 타입}
\subsubsection{count}
업스트림이 onComplete 이벤트를 보낼 때에 onNext를 보낸다.

\subsubsection{reduce/reduceWith}

\section{지연}
\subsection{delay}
timer와 비슷하다.
기본으로 computation Scheduler 사용한다.

delay(long delay, TimeUnit unit)

delay(long delay, TimeUnit unit, boolean delayError)

delay(long delay, TimeUnit unit, Scheduler scheduler)

delay(long delay, TimeUnit unit, Scheduler scheduler, boolean delayError)

delay(final Function<? super T, ? extends ObservableSource<U>> itemDelay)

delay(ObservableSource<U> subscriptionDelay,
            Function<? super T, ? extends ObservableSource<V>> itemDelay)

\subsection{delaySubscription}

delaySubscription(long delay, TimeUnit unit)


           
\section{일괄처리/샘플링}
다음 장의 배압을 요구하기 전에 사용할 수 있는 옵션을 얘기해보자.

\subsection{buffer}
window 연산자와 함께 얘기되는 경우가 많다.
Observable.buffer(2, 1)
앞의 것과 비교하고자 할 때 사용해도  된다.

\subsection{스로틀}
\subsubsection{throttleLast/sample}

\subsubsection{throttleFirst}

\subsubsection{throttleWithTimeout/debounce}

\section{Observable 결합}
기존 Observable 여러 개를 가지고서 하나의 Observale로 만들어 내는 연산자를 얘기하자.
위의 변환의 범주에 넣을 수도 있다.

\subsection{머지}
타입이 동일해야만 한다.
\subsubsection{startWith 시리즈}
시퀀스 개수가 달라진다. 아래와 같이 4개의 메서드가 있다. 
startWith(Iterable<? extends T> items)
startWith(ObservableSource<? extends T> other)
startWith(T item)
startWithArray(T... items) 

컬렉션과 다른 Observable, 아이템 1개, 배열을 시퀀스 앞에 추가한다.
타입이 동일해야 한다.

\subsubsection{flatMap}
타입이 바뀐다.

flatten화 한다. 
flatMap(obs -> obs) 로 항등함수를 사용할 수 있다.
화살표 왼쪽에서 observable이 들어가는 희한한 방식인데 목적은 화살표 오른쪽의 observable을 flatten하게 한다.

flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper)

flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors)

flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency)

flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper,
            boolean delayErrors, int maxConcurrency, int bufferSize)

flatMap(Function<? super T, ? extends ObservableSource<? extends R>> onNextMapper,
            Function<? super Throwable, ? extends ObservableSource<? extends R>> onErrorMapper,
            Callable<? extends ObservableSource<? extends R>> onCompleteSupplier)

flatMap(Function<? super T, ? extends ObservableSource<? extends R>> onNextMapper,
            Function<Throwable, ? extends ObservableSource<? extends R>> onErrorMapper,
            Callable<? extends ObservableSource<? extends R>> onCompleteSupplier,
            int maxConcurrency)
            
flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int maxConcurrency)


flatMap(Function<? super T, ? extends ObservableSource<? extends U>> mapper,
            BiFunction<? super T, ? super U, ? extends R> resultSelector)

flatMap(Function<? super T, ? extends ObservableSource<? extends U>> mapper,
            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors)

flatMap(Function<? super T, ? extends ObservableSource<? extends U>> mapper,
            BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency)


flatMap(final Function<? super T, ? extends ObservableSource<? extends U>> mapper,
            final BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayErrors, int maxConcurrency, int bufferSize)


flatMap(Function<? super T, ? extends ObservableSource<? extends U>> mapper,
            BiFunction<? super T, ? super U, ? extends R> combiner, int maxConcurrency)

flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper)
flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper,
            BiFunction<? super T, ? super U, ? extends V> resultSelector)

flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper)
flatMapCompletable(Function<? super T, ? extends CompletableSource> mapper, boolean delayErrors)


flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper)
flatMapMaybe(Function<? super T, ? extends MaybeSource<? extends R>> mapper, boolean delayErrors)

flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper)
flatMapSingle(Function<? super T, ? extends SingleSource<? extends R>> mapper, boolean delayErrors)
                                                                        
\subsubsection{merge/mergeWith}
정적 메서드 merge와 인스턴스 메서드 mergeWith가 있다.
내부적으로 flatMap을 사용한다.
flatMap(obs -> obs)
mergeArray



\subsubsection{mergeDelayError}
mergeArrayDelayError

\subsection{연결}
\subsubsection{concatMap}
concatMapDelayError, concatMapEager, concatMapEagerDelayError
concatMapIterable

\subsubsection{concat/concatWith}
flatMap과 merge 관계처럼 concat도 concatMap을 사용한다.
concatArrayDelayError
concatEager, concatArrayEager
concatDelayError

\subsection{전환}
\subsubsection{switchMap}
switchMapSingleDelayError
switchMapDelayError

\subsubsection{switchOnNext}
switch나 switchWith 메서드는 없다.
정적 메서드이다. 
내부적으로 switchMap 사용한다.
switchOnNextDelayError


\begin{verbatim}
public static <T> Observable<T> switchOnNext(ObservableSource<? extends ObservableSource<? extends T>> sources, int bufferSize) {
	ObjectHelper.requireNonNull(sources, "sources is null");
	ObjectHelper.verifyPositive(bufferSize, "bufferSize");
	return RxJavaPlugins.onAssembly(new ObservableSwitchMap(sources, Functions.identity(), bufferSize, false));
}
\end{verbatim}

\subsubsection{switchOnNextDelayError}

switchIfEmpty


\subsection{페어링}
앞의 머지, 연결, 전환에서는 동일한 이벤트 타입이 필요했다.

\subsubsection{zip/zipWith}
일대일일 때 많이 사용한다.
한 Observable이 1초마다 이벤트를 방출하고 다른 Observable이 1.1초라고 한다면 이 2개를 결합하면 10시간 후에는 한 시간 차이가 생겨버린다.
2개의 시퀀스가 인덱스로 결합한다.

zipWith는 zip을 다시 호출한다.
\begin{verbatim}
    public final <U, R> Observable<R> zipWith(ObservableSource<? extends U> other,
BiFunction<? super T, ? super U, ? extends R> zipper) {
	ObjectHelper.requireNonNull(other, "other is null");
	return zip(this, other, zipper);
}
\end{verbatim}

zipArray
zipIterable

\subsubsection{combineLatest}
zip보다 실제 많이 사용된다.

combineLatestDelayError

\subsubsection{withLatestFrom}

\subsubsection{join}
% http://www.introtorx.com/uat/content/v1.0.10621.0/17_SequencesOfCoincidence.html#Join
% The Join operator allows you to logicaly join two sequences. Where the Zip operator would join two seqences together by index, the Join operator allows you join sequences by intersecting windows.
Observable에서 제일 복잡한 시그너쳐 가운데 하나다. 
\begin{verbatim}
    public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> join(
            ObservableSource<? extends TRight> other,
            Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd,
            Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd,
            BiFunction<? super T, ? super TRight, ? extends R> resultSelector)
\end{verbatim}
앞의 zip, combineLatest, withLatestFrom은 일대일로 결합이 되었는데 여기서는 다대다로 결합이 가능하다.
leftEnd 파라미터가 업스트림 각 이벤트의 만료 시점을 나타내고 rightEnd 파라미터가 other Observable의 각 이벤트의 만료 시점을 나타낸다.
% ObservableJoinTest 참고할 것

구구단을 만들어보았다. flatMap을 사용한 버전과 비교해보자.
\begin{verbatim}
    Observable.range(1, 9)
        .join(Observable.range(2, 8),
            i -> Observable.never(),
            i -> Observable.never(),
            (row, col) -> String.format("%d x %d = %d", col, row, col * row))
        .subscribe(System.out::println);
\end{verbatim}
만료 조건이 never로 되어 있어서 업스트림의 이벤트나 other Observable의 이벤트는 만료되지 않고 모든 이벤트가 교차된다.

\subsubsection{groupJoin}

\begin{verbatim}
    public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> groupJoin(
            ObservableSource<? extends TRight> other,
            Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd,
            Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd,
            BiFunction<? super T, ? super Observable<TRight>, ? extends R> resultSelector) 
\end{verbatim}
\subsection{amb}
ambiguous
모호한, 분명하지 않은 의미를 가진다.

amb와 ambArray 메서드가 있다.

flatMap, switchMap에 전달되는 Observable이 Observable.empty라고 해서 그 다음에 onComplete를 보내는 것이 아니다. 헷갈릴 수 있다.

\section{Observable 분기}
앞 절의 결합 연산자에 대응하는 장이다. 
분기 연산자는 하나의 Observable을 여러 개의 Observable로 만든다.
따라서 분기하는 기준이 필요해진다.
분기에서 끝나지는 않고 다시 머지하는 과정이 필요하다.

\subsection{window}
buffer 연산자와 함께 얘기되는 경우가 많다.
법인카드 사용 내역을 Observable로 만들었다고 해보자.
이것을 하루씩 끊어서 살펴보려고 할 수 있다. 
% 사용 내역에서 특이사항을 체크해볼 수도 있다.
Observable<Observable<T>>을 리턴한다.
window(long count)
window(long count, long skip)
window(long count, long skip, int bufferSize)
window(long timespan, long timeskip, TimeUnit unit)
window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler)
window(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler, int bufferSize)
window(long timespan, TimeUnit unit)
window(long timespan, TimeUnit unit, Scheduler scheduler)
window(long timespan, TimeUnit unit, long count)
한 윈도우 내에서 최대 개수
window(long timespan, TimeUnit unit, long count, boolean restart)
개수에 다다르면 다시 시작한다.
window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count)
window(long timespan, TimeUnit unit,
            Scheduler scheduler, long count, boolean restart)
window(long timespan, TimeUnit unit, Scheduler scheduler,
            long count, boolean restart, int bufferSize)
window(ObservableSource<B> boundary)
window(ObservableSource<B> boundary, int bufferSize)
            
\subsection{groupBy}
법인카드 사용 내역을 사용자별로 구분해서 보려고 할 수도 있다.
GroupedObservable은 Key가 있는 것 뿐이다.

\section{에러 처리}
onErrorReturn
onErrorReturnItem
onExceptionResumeNext
retry, retryUntil, retryWhen

\section{기타}
\subsection{cache/cacheWithInitialCapacity}
\subsection{toFuture}
fromFuture와 반대이다.

\subsection{defaultIfEmpty}
defaultIfEmpty(T defaultItem)

switchIfEmpty(just(defaultItem))을 호출한다.

\subsection{serialize}
쓸 일이 없다. 만일 ObservableSource에서 여러 스레드를 사용한다면 모든 아이템을 출력하기 위해서 필요하다.

onTerminateDetach


\chapter{배압과 Flowable}
https://en.wikipedia.org/wiki/Back_pressure
Backpressure in information technology에 나온다.
The term is also used analogously in the field of information technology to describe the build-up of data behind an I/O switch if the buffers are full and incapable of receiving any more data; the transmitting device halts the sending of data packets until the buffers have been emptied and are once more capable of storing information. It also refers to an algorithm for routing data according to congestion gradients

튜브에 바람을 넣을 때 아직 많이 넣을 수 있는데도 바람을 넣을 때 반작용이 있다.

Observale이 Observer가 요청하는 것보다 많이 만들어낸다.
이때 초과되는 것을 버리거나 버퍼에 쌓거나 오래된 것은 제거하는 방법을 쓸 수 있다.

Flowable에서 filter, distinct, distinctUntilChanged, skipLast, skipWhile, skipUntil 에서는 request(1)한다.

FlowableOnSubscribe
FlowableEmitter

\chapter{Maybe/Single/Completable}

\section{Maybe}
MaybeOnSubscribe
MaybeEmitter
\section{Single}
SingleOnSubscribe
SingleEmitter

\section{Completable}
CompletableOnSubscribe
CompletableEmitter

쓸만한 게 많다.
Observable<T> andThen(ObservableSource<T> next)
Flowable<T> andThen(Publisher<T> next)
Single<T> andThen(SingleSource<T> next)
 

\chapter{사용자 정의 연산자}
Transformer/to/커스텀 연산자
가능하면 만들지 말자.

\section{to}
소스 타입 간 변환에 많이 사용된다.

\section{compose}


\section{lift}

https://github.com/akarnokd/RxJava2Extensions

https://github.com/davidmoten/rxjava2-extras
여기에 cache 연산자가 있다.



\chapter{디버깅과 테스트}	
\section{doOnXxx 연산자}
doAfterNext
doAfterTerminate
doFinally
doOnDispose
doOnEach
doOnError
doOnLifecycle
doOnNext
doOnSubscribe
doOnTerminate

\section{blocking 연산자}
blockingFirst,
blockingForEach,
blockingIterable,
blockingLast,
blockingLatest,
blockingMostRecent,
blockingNext,
blockingSingle,
blockingSubscribe

\section{TestObserver}

\section{TestScheduler}

\chapter{RxJava와 함께 하는 라이브러리}
https://github.com/ReactiveX/RxAndroid/wiki

RxJava와 함께 하는 도구들을 준비하자. 


\section{Retrofit}
With Adapter
다이나믹 프록시

% POST, PUT, GET, DELETE 적용
%  커스텀도 가능하다.
GET에는 Body가 전달되지 않는다. 

\subsection{컨버터}
XML 파싱에는 SimpleXmlConverter가 있고 JSON 파싱에는 JacksonConverter, GsonConverter가 있다.
jackson은 성능이 좋은 편이다. 하지만 신뢰도가 높지는 않다.

\subsubsection{커스텀 컨버터}
데이터 구조가 복잡한 경우 직접 파싱하고 싶을 때가 있다. 
예) 좌표 to 주소

\subsection{어댑터}
https://github.com/square/retrofit/tree/master/retrofit-adapters
이 가운데서 rxjava2 어댑터를 사용해야 한다.

compile 'com.squareup.retrofit2:adapter-rxjava2:2.2.0'

create(), createAsync(), createWithScheduler(Scheduler scheduler) 3개의 메서드가 있다.

스케줄러 전달 가능하다.

프라이빗 메서드인 RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync)를 사용한다.



\section{RxAndroid}
안드로이드에서는 필수적인 유틸리티이다. 메인 스레드에서만 UI 업데이트를 허용한다.

https://github.com/ReactiveX/RxAndroid

Observable에서 observeOn(AndroidSchedulers.mainThread()) 이 메서드만 주로 사용한다.
onNext의 내용은 Handler의 post 메서드에 전달된다.

\section{RxBinding}
https://github.com/JakeWharton/RxBinding

compile 'com.jakewharton.rxbinding2:rxbinding:2.0.0'

RxView에서는 Observable을 리턴하는 것과 Consumer를 리턴하는 것을 구분해야 한다.
clickable
enabled
pressed
selected
visibility
는 Consumer를 리턴하는 것이다.

throttle 이 편하다.

\section{RxRelay}
Subject는 터미널 이벤트를 받으면 더 이벤트를 받을 수 없다.
onNext()가 아닌 accept() 메서드를 사용한다.

https://github.com/JakeWharton/RxRelay


\chapter{RxJava 응용}
\section{RxBus}
onNext 호출 위치가 스레드인가 아닌가에 따라서 Observer도 영향을 받는다.


% 순수함수
% https://www.slideshare.net/yfain/reactive-thinking-in-java-with-rxjava2
